<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>VWorld 주소 → 마킹 + 지번 외곽선 예제</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; }
    #top { padding:10px; background:#0b69a3; color:#fff; }
    #controls { display:flex; gap:8px; align-items:center; }
    #addressInput { width:400px; padding:6px; border-radius:4px; border:1px solid #ccc; }
    #map { width:100%; height:80vh; }
    #info { padding:8px; font-size:14px; }
    button { padding:6px 10px; border-radius:4px; border:none; cursor:pointer; }
    button.primary { background:#ff8a00; color:#fff; }
  </style>

  <!-- VWorld map 초기화 스크립트 (apiKey 쿼리 파라미터에 본인의 키를 넣음) -->
  <script
    type="text/javascript"
    src="https://map.vworld.kr/js/vworldMapInit.js.do?version=2.0&apiKey=BE552462-0744-32DB-81E7-1B7317390D68">
  </script>
</head>
<body>
  <div id="top">
    <div id="controls">
      <div>주소 입력:</div>
      <input id="addressInput" placeholder="예: 서울특별시 중구 세종대로 110" />
      <button id="searchBtn" class="primary">찾기</button>
      <button id="clearBtn">레이어 초기화</button>
    </div>
  </div>

  <div id="map"></div>
  <div id="info">검색 결과가 여기 표시됩니다.</div>

  <script>
    // 전역 변수
    let vmap, markerLayer, parcelLayer;
    const apiKey = "BE552462-0744-32DB-81E7-1B7317390D68";

    // VWorld OpenLayers 기반 맵 초기화 (예제 방식)
    vw.ol3.MapOptions = {
      basemapType: vw.ol3.BasemapType.GRAPHIC,
      controlDensity: vw.ol3.DensityType.EMPTY,
      interactionDensity: vw.ol3.DensityType.BASIC,
      controlsAutoArrange: true
    };
    vmap = new vw.ol3.Map("map", vw.ol3.MapOptions);

    // 마커 레이어 생성 함수
    function ensureMarkerLayer() {
      if (!markerLayer) {
        markerLayer = new vw.ol3.layer.Marker(vmap);
        vmap.addLayer(markerLayer);
      }
    }

    // 폴리곤(필지) 레이어 생성/삭제
    function ensureParcelLayer() {
      if (!parcelLayer) {
        parcelLayer = new ol.layer.Vector({
          source: new ol.source.Vector(),
          style: new ol.style.Style({
            stroke: new ol.style.Stroke({ color: 'rgba(0,120,200,0.9)', width: 3 }),
            fill: new ol.style.Fill({ color: 'rgba(0,120,200,0.15)' })
          })
        });
        vmap.addLayer(parcelLayer);
        parcelLayer.set('name','parcelLayer');
      }
    }
    function clearLayers() {
      if (markerLayer) markerLayer.clear();
      if (parcelLayer) parcelLayer.getSource().clear();
      document.getElementById('info').textContent = '레이어 초기화됨';
    }

    // 주소 → 좌표 (Geocoding) - VWorld Geocoder API 사용
    async function geocodeAddress(address) {
      const url = "https://api.vworld.kr/req/address";
      const params = new URLSearchParams({
        service: "address",
        request: "getCoord",
        key: apiKey,
        type: "ROAD",      // ROAD(도로명) 또는 PARCEL(지번)
        address: address,
        format: "json"
      });
      const fetchUrl = `${url}?${params.toString()}`;
      // fetch (CORS 문제 발생 가능 — 그 경우 백엔드 프록시 필요)
      const res = await fetch(fetchUrl);
      if (!res.ok) throw new Error('Geocode 요청 실패: ' + res.status);
      const j = await res.json();
      // 응답 포맷이 약간씩 달라서 안전하게 경로 검사
      const items = j?.response?.result?.items || j?.response?.result || j?.response?.result?.items || j?.result?.items;
      // 보통 items[0].point.x / .y 형태
      const first = Array.isArray(items) && items.length ? items[0] : null;
      if (!first) throw new Error('검색 결과가 없습니다.');
      // 일부 응답은 first.point.x/y, 또는 first.x/y 등으로 올 수 있음
      const x = first?.point?.x ?? first?.x ?? first?.lon ?? first?.lng;
      const y = first?.point?.y ?? first?.y ?? first?.lat;
      if (!x || !y) throw new Error('좌표를 해석할 수 없습니다.');
      return { lon: parseFloat(x), lat: parseFloat(y), raw: first };
    }

    // 마커 추가 및 맵 이동
    function addMarker(lon, lat, title) {
      ensureMarkerLayer();
      markerLayer.clear();
      const feature = markerLayer.addMarker([lon, lat], { title: title || '찾은 위치' });
      const coord = ol.proj.transform([lon, lat], 'EPSG:4326', 'EPSG:900913');
      vmap.getView().setCenter(coord);
      vmap.getView().setZoom(18);
      return feature;
    }

    // 필지(지번) 외곽선 가져오기 (예제: 2D data API getFeature 사용 템플릿)
    // 실제로는 dataset 명 / 필터 방식이 달라질 수 있음 -> 문서 확인 필요
    async function fetchParcelPolygon(pnuOrFilter) {
      // 예시 엔드포인트 (2D data API) — 실제 data 파라미터(데이터셋 아이디)는 상황에 맞게 수정하세요.
      // (문서: VWorld 2D Data API 참고) :contentReference[oaicite:3]{index=3}
      const base = "https://api.vworld.kr/2d/data";
      const params = new URLSearchParams({
        service: "data",
        request: "getFeature",
        key: apiKey,
        data: "cadastral",          // ⚠️ 예시: 실제 데이터셋 ID를 문서에서 확인 필요
        attribute: "pnu",           // 속성 필드명 예시
        pnu: pnuOrFilter,           // 또는 attrFilter 사용
        format: "json"
      });
      const url = `${base}?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('필지 데이터 요청 실패: ' + res.status);
      const j = await res.json();
      // 응답에서 geometry(폴리곤 좌표)를 찾아 GeoJSON으로 변환해야 함.
      // 실제 응답 포맷이 다를 수 있으니 콘솔에 찍어 확인하세요.
      return j;
    }

    // 필지(폴리곤) 그리기 (GeoJSON 형식으로 올 경우)
    function drawParcelFromGeoJSON(geojson) {
      ensureParcelLayer();
      const format = new ol.format.GeoJSON();
      const features = format.readFeatures(geojson, { dataProjection: 'EPSG:4326', featureProjection: 'EPSG:900913' });
      parcelLayer.getSource().clear();
      parcelLayer.getSource().addFeatures(features);
      if (features.length) {
        const extent = parcelLayer.getSource().getExtent();
        vmap.getView().fit(extent, { padding: [30,30,30,30], maxZoom: 19 });
      }
    }

    // UI 이벤트 바인딩
    document.getElementById('searchBtn').addEventListener('click', async () => {
      const address = document.getElementById('addressInput').value.trim();
      if (!address) { alert('주소를 입력하세요.'); return; }
      document.getElementById('info').textContent = '주소 검색 중...';
      try {
        const g = await geocodeAddress(address);
        document.getElementById('info').textContent = `좌표: ${g.lon.toFixed(6)}, ${g.lat.toFixed(6)}`;
        addMarker(g.lon, g.lat, address);

        // --- 아래는 필지(지번) 외곽선을 가져오는 흐름의 예시 ---
        // 1) geocode 결과에 pnu(필지번호)가 포함되어 있다면 그것을 사용해서 필지 조회
        // 2) 없으면 getLandCharacteristics 같은 API로 pnu를 얻은 뒤 2D data에서 geometry 조회
        const pnuFromGeocode = g.raw?.pnu ?? g.raw?.parcel?.pnu ?? null;
        if (pnuFromGeocode) {
          document.getElementById('info').textContent += ` | PNU: ${pnuFromGeocode} (필지 조회 시도)`;
          // fetchParcelPolygon 함수는 API-응답 포맷에 맞게 수정 필요
          try {
            const parcelResp = await fetchParcelPolygon(pnuFromGeocode);
            console.log('parcelResp', parcelResp);
            // 만약 API가 GeoJSON을 바로 준다면 drawParcelFromGeoJSON(parcelResp);
            // 예시: 아래는 응답이 geojson.features 형태일 때
            if (parcelResp?.features) {
              drawParcelFromGeoJSON(parcelResp);
              document.getElementById('info').textContent += ' | 필지 외곽선 표시 완료';
            } else {
              document.getElementById('info').textContent += ' | 필지 데이터는 콘솔 확인 필요 (응답포맷 상이)';
              console.log('필지 응답(확인 필요):', parcelResp);
            }
          } catch (e) {
            console.error(e);
            document.getElementById('info').textContent += ' | 필지 조회 실패(콘솔 확인)';
          }
        } else {
          document.getElementById('info').textContent += ' | PNU 없음 → getLandCharacteristics 등으로 추가 조회 필요';
        }

      } catch (err) {
        console.error(err);
        alert('오류: ' + err.message);
        document.getElementById('info').textContent = '오류 발생 — 콘솔 확인';
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => { clearLayers(); });

    // 시작시 레이어 준비
    ensureMarkerLayer();
    ensureParcelLayer();
  </script>
</body>
</html>
